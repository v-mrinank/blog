
[{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/tags/celery/","section":"Tags","summary":"","title":"Celery","type":"tags"},{"content":" Introduction # RabbitMQ is a powerful message-queueing system that forms the backbone of many distributed applications. However, as the number of queues grows, managing them can become a daunting task. In this blog post, we\u0026rsquo;ll explore how to efficiently manage RabbitMQ queues using the rabbitmqadmin tool and Python scripts.\nWe\u0026rsquo;ll start by setting up rabbitmqadmin and configuring it to work with an authenticated RabbitMQ instance. Then, we\u0026rsquo;ll dive into the challenges that arise when dealing with a large number of queues and how to overcome them using Python and the RabbitMQ Management HTTP API.\nYou\u0026rsquo;ll learn how to:\nRetrieve queues in batches Filter queues based on specific criteria using regular expressions Safely delete unnecessary queues We\u0026rsquo;ll also discuss best practices for:\nHandling exceptions Storing the results for further analysis By the end of this post, you\u0026rsquo;ll have a solid understanding of how to automate the management of RabbitMQ queues, saving you time and effort in maintaining your messaging infrastructure. Let\u0026rsquo;s get started!\nTools Used # In this blog post, we\u0026rsquo;ll be using the following tools and libraries:\nRabbitMQ # RabbitMQ : A powerful message-queueing system that enables reliable communication between distributed application components. RabbitMQ Management Console : A web-based user interface for managing and monitoring RabbitMQ servers and queues. rabbitmqadmin # rabbitmqadmin : A command-line tool provided by RabbitMQ for performing administrative tasks, such as listing and deleting queues. Python # Python: A versatile programming language used for scripting and automating tasks. Python Libraries: yaml : Used for parsing YAML configuration files. requests : Used for making HTTP requests to the RabbitMQ Management HTTP API. re : Used for working with regular expressions to filter queues based on specific criteria. Assumptions and Preconditions # Before diving into the blog post, we assume the following:\nYou have a basic understanding of RabbitMQ and its concepts, such as queues, exchanges, and bindings. You have RabbitMQ installed and running on your system. You have access to the RabbitMQ Management Console and the necessary credentials (username and password) to authenticate. You have Python installed on your system, along with the required libraries (yaml, requests, and re). You are comfortable working with the command line and running Python scripts. With these tools and assumptions in mind, you\u0026rsquo;ll be well-equipped to follow along with the examples and techniques presented in this blog post to efficiently manage your RabbitMQ queues.\nrabbitmqadmin # Introduction # rabbitmqadmin is a powerful command-line tool provided by RabbitMQ for managing and monitoring RabbitMQ servers and queues. It allows you to perform various administrative tasks, such as listing queues, exchanges, and bindings, as well as publishing and consuming messages.\nDownloading and Setting Up rabbitmqadmin # To get started with rabbitmqadmin, you first need to download it from the RabbitMQ Management portal. You can do this by running the following commands:\nwget http://localhost:15672/cli/rabbitmqadmin chmod +x rabbitmqadmin The first command downloads the rabbitmqadmin tool from the RabbitMQ Management portal running on localhost at port 15672. The second command changes the permissions of the downloaded file to make it executable.\nChanging the permissions is necessary because, by default, the downloaded file may not have the execute permission set. By running chmod +x rabbitmqadmin, you grant the file execute permissions, allowing you to run it as a command-line tool.\nAuthentication with rabbitmqadmin # In many cases, RabbitMQ is configured with authentication enabled to secure access to the management interface. To use rabbitmqadmin with an authenticated RabbitMQ instance, you need to provide the username and password.\nOne way to do this is by passing the username and password as command-line arguments:\n./rabbitmqadmin -u \u0026lt;username\u0026gt; -p \u0026lt;password\u0026gt; list queues However, this approach has a significant drawback. By passing the password as a command-line argument, it becomes visible in the command history and may be logged or exposed in various ways. This poses a security risk, especially if you are sharing your terminal or working in a collaborative environment.\nUsing a Configuration File # To avoid exposing sensitive information like passwords on the command line, it is recommended to use a configuration file. Create a file named rabbitmqadmin.conf with the following content:\n[default] hostname = localhost port = 15672 username = your_username password = your_password vhost = your_vhost Replace your_username, your_password, and your_vhost with your actual RabbitMQ credentials and virtual host.\nWith the configuration file in place, you can now run rabbitmqadmin commands without specifying the credentials on the command line:\n./rabbitmqadmin --config rabbitmqadmin.conf list queues This approach keeps your sensitive information separate from the command and prevents it from being exposed in the command history or logs.\nBy leveraging rabbitmqadmin and using a configuration file for authentication, you can efficiently manage your RabbitMQ instance from the command line while maintaining the security of your credentials.\nExamples # Declaring a queue:\n./rabbitmqadmin --config rabbitmqadmin.conf declare queue name=my_queue durable=true This command declares a new queue named my_queue with the durable flag set to true, ensuring that the queue persists even if the RabbitMQ server restarts.\nPublishing a message:\n./rabbitmqadmin --config rabbitmqadmin.conf publish exchange=my_exchange routing_key=my_key payload=\u0026#34;Hello, RabbitMQ!\u0026#34; This command publishes a message with the payload \u0026ldquo;Hello, RabbitMQ!\u0026rdquo; to the exchange my_exchange using the routing key my_key.\nConsuming messages:\n./rabbitmqadmin --config rabbitmqadmin.conf get queue=my_queue count=10 This command consumes and retrieves up to 10 messages from the queue my_queue.\nDeleting a queue:\n./rabbitmqadmin --config rabbitmqadmin.conf delete queue name=my_queue This command deletes the queue named my_queue from your RabbitMQ instance.\nPurging a queue:\n./rabbitmqadmin --config rabbitmqadmin.conf purge queue name=my_queue This command purges (removes) all the messages from the queue named my_queue without deleting the queue itself.\nThese are just a few examples of the many operations you can perform using the rabbitmqadmin tool. It provides a wide range of functionality for managing and monitoring your RabbitMQ instance from the command line.\nAutomation and Testing using rabbitmqadmin # The interesting part is publishing and consuming messages for application development, and testing. If we have a shell script like below, we can make it a part of testing scripts and other automations.\n#!/bin/bash ## Set the path to the rabbitmqadmin tool and configuration file RABBITMQADMIN=\u0026#34;/path/to/rabbitmqadmin\u0026#34; CONFIG_FILE=\u0026#34;/path/to/rabbitmqadmin.conf\u0026#34; ## Set the exchange name, routing key, and message payload EXCHANGE_NAME=\u0026#34;my_exchange\u0026#34; ROUTING_KEY=\u0026#34;my_key\u0026#34; MESSAGE_PAYLOAD=\u0026#34;Hello, RabbitMQ!\u0026#34; ## Publish a message to the specified exchange with the given routing key $RABBITMQADMIN --config $CONFIG_FILE publish exchange=$EXCHANGE_NAME routing_key=$ROUTING_KEY payload=\u0026#34;$MESSAGE_PAYLOAD\u0026#34; I can also easily see this working with crontabs and other schedulers.\nGenesis of this blog # So the rabbitmqadmin tool is pretty nice but there are limitations to its capabilities. It is basically a wrapper around the RabbitMQ Management Consoles HTTP REST APIs. So I faced a peculiar problem wherein my team accidently pushed around 200,000 (2 hundred thousand or 2 lakhs) of undesired queues in to RabbitMQ cluster using Celery becase of a mistype in Python celery code.\nLet us discuss how we end up here.\nThe Dangers of Not Using ignore_result in Celery Tasks # When working with Celery, a popular distributed task queue library for Python, it\u0026rsquo;s crucial to be mindful of how you configure your tasks. One often overlooked setting is ignore_result, which can have significant implications for the performance and stability of your RabbitMQ message broker.\nBy default, when a Celery task is executed, the result of the task is stored in a result backend, such as Redis or RabbitMQ. This allows the worker to retrieve the result later if needed. However, if you don\u0026rsquo;t explicitly set ignore_result=True for tasks that don\u0026rsquo;t require the result to be stored, Celery will automatically create a result queue for each task.\nHere\u0026rsquo;s where the problem lies. If you have a high volume of tasks being processed and you\u0026rsquo;re not using ignore_result, RabbitMQ can quickly become overwhelmed with a large number of result queues. Each task execution will create a new queue, leading to a rapid accumulation of queues in RabbitMQ.\nThe consequences of this can be severe:\nIncreased Resource Consumption: As the number of queues grows, RabbitMQ requires more memory and CPU resources to manage and maintain them. This can put a significant strain on your RabbitMQ server, leading to increased resource utilization and potentially causing performance issues.\nReduced Performance: When RabbitMQ is burdened with a large number of queues, it can start to slow down. The processing of messages and the overall throughput of the system can be impacted, resulting in longer task execution times and reduced responsiveness.\nInstability and Crashes: In extreme cases, the excessive number of queues can cause RabbitMQ to become unstable or even crash. The server may struggle to handle the sheer volume of queues and the associated overhead, leading to service disruptions and potential data loss.\nTo mitigate these issues, it\u0026rsquo;s important to use the ignore_result parameter judiciously in your Celery tasks. If you don\u0026rsquo;t need the result of a task to be stored, make sure to set ignore_result=True when defining the task. This tells Celery not to create a result queue for that task, reducing the burden on RabbitMQ.\nHere\u0026rsquo;s an example of how to set ignore_result in a Celery task:\n@app.task(ignore_result=True) def my_task(): ## Task logic goes here pass By setting ignore_result=True, you ensure that no result queue is created for the task, thereby preventing the accumulation of unnecessary queues in RabbitMQ.\nSo my team mate mistyped ignore_result to ignore_results, and as python is python, it gave no warnings at all. This led to a sudden increase in queues and a sudden degradation of rabbitmq cluster performance.\nManagement Console REST API # The RabbitMQ management UI and rabbitmqadmin have limited capabilities when it comes to performing bulk operations on queues, exchanges, bindings, etc. For example, if you need to delete hundreds of queues matching a certain naming pattern, it would be quite tedious to do this through the UI or rabbitmqadmin. The REST API allows you to programmatically perform operations on many objects much more efficiently.\nThe management UI doesn\u0026rsquo;t provide a way to export or save the configuration and state of RabbitMQ objects. Using the REST API, you could write a script to get the definitions of all exchanges, queues, bindings, etc. and save them to a file. This could be useful for backing up the configuration or copying it to another RabbitMQ cluster.\nAdvanced configuration tasks like setting policies and parameters are not possible through the rabbitmqadmin tool, you can only do this through the management UI or REST API. Using the API would allow you to automate these configuration changes.\nThere are some settings and statistics which are only accessible via the REST API and not exposed in the management UI, such as detailed memory usage breakdown. Accessing the REST API programmatically would allow you to retrieve this additional information.\nThe management UI and rabbitmqadmin are great for interactive, ad-hoc administration and monitoring of a RabbitMQ cluster. But for more advanced automation, configuration management, monitoring, and bulk operations, using the REST API directly provides a lot more power and flexibility. Most things you can do in the UI, and more, can be done through the API.\nToo Many Queues # The main issue we encountered was the presence of too many queues, which led to connection timeouts when making HTTP requests through the management console or rabbitmqadmin. To address this problem, we decided to write a custom Python program that interacts directly with the RabbitMQ REST API.\nOur Python programs will perform the following steps:\nLoad the RabbitMQ configuration from a YAML file. Retrieve queues in batches using the REST API. Process the retrieved queues and identify the ones to be deleted. Store the queues to be deleted in a separate file. Delete the identified queues using the REST API. The programs # # get_queues.py import yaml import requests import re # Load the configuration from the YAML file with open(\u0026#39;rabbitmq.conf\u0026#39;, \u0026#39;r\u0026#39;) as file: config = yaml.safe_load(file) # Extract the configuration values hostname = config[\u0026#39;hostname\u0026#39;] port = config[\u0026#39;port\u0026#39;] username = config[\u0026#39;username\u0026#39;] password = config[\u0026#39;password\u0026#39;] vhost = config[\u0026#39;vhost\u0026#39;] # Set the API endpoint URL api_url = f\u0026#34;http://{hostname}:{port}/api/queues/{vhost}\u0026#34; # Set the batch size batch_size = 100 # Set the initial offset offset = 1 # Open the file to store the queues with open(\u0026#39;queues_to_delete.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # Download queues in batches while True: # Set the pagination parameters params = { \u0026#39;page\u0026#39;: offset, \u0026#39;page_size\u0026#39;: batch_size, \u0026#39;columns\u0026#39;: \u0026#39;name,messages\u0026#39; } try: # Send a GET request to the API endpoint with authentication response = requests.get(api_url, auth=(username, password), params=params) # Check if the request was successful if response.status_code == 200: try: # Parse the JSON response queues = response.json()[\u0026#39;items\u0026#39;] # Process the retrieved queues for queue in queues: queue_name = queue[\u0026#39;name\u0026#39;] message_count = queue[\u0026#39;messages\u0026#39;] print(f\u0026#34;Queue: {queue_name}, Messages: {message_count}\u0026#34;) # Check if the queue name does not contain \u0026#34;karna\u0026#34; using regex if not re.search(r\u0026#39;arjun\u0026#39;, queue_name): file.write(queue_name + \u0026#39;\\n\u0026#39;) # Break the loop if no more queues are retrieved if len(queues) \u0026lt; batch_size: break # Increment the offset for the next batch offset += 1 except (KeyError, TypeError, ValueError) as e: print(f\u0026#34;Error parsing JSON response: {e}\u0026#34;) print(\u0026#34;Skipping to the next batch...\u0026#34;) offset += 1 continue else: print(f\u0026#34;Error: {response.status_code} - {response.text}\u0026#34;) break except requests.exceptions.RequestException as e: print(f\u0026#34;Error: {e}\u0026#34;) break # delete_queues.py import yaml import requests # Load the configuration from the YAML file with open(\u0026#39;rabbitmq.conf\u0026#39;, \u0026#39;r\u0026#39;) as file: config = yaml.safe_load(file) # Extract the configuration values hostname = config[\u0026#39;hostname\u0026#39;] port = config[\u0026#39;port\u0026#39;] username = config[\u0026#39;username\u0026#39;] password = config[\u0026#39;password\u0026#39;] vhost = config[\u0026#39;vhost\u0026#39;] # Set the API endpoint URL api_url = f\u0026#34;http://{hostname}:{port}/api/queues/{vhost}\u0026#34; # Open the file to read the queues with open(\u0026#39;queues_to_delete.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: queues_to_delete = file.read().splitlines() # Delete the queues that don\u0026#39;t contain \u0026#34;karna\u0026#34; for queue_name in queues_to_delete: try: # Send a DELETE request to the API endpoint with authentication delete_url = f\u0026#34;{api_url}/{queue_name}\u0026#34; response = requests.delete(delete_url, auth=(username, password)) # Check if the request was successful if response.status_code == 204: print(f\u0026#34;Deleted queue: {queue_name}\u0026#34;) else: print(f\u0026#34;Error deleting queue \u0026#39;{queue_name}\u0026#39;: {response.status_code} - {response.text}\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;Error deleting queue \u0026#39;{queue_name}\u0026#39;: {e}\u0026#34;) Let\u0026rsquo;s dive into the Python code and understand how it works.\nLoading Configuration # We start by loading the RabbitMQ configuration from a YAML file named rabbitmq.conf. The configuration file contains the following attributes:\nhostname: localhost port: 15672 username: your_username password: your_password vhost: your_vhost We use the yaml module to parse the configuration file and extract the necessary values.\nRetrieving Queues # To retrieve queues efficiently, we use a pagination approach. We define a batch size and an initial offset. We then make GET requests to the RabbitMQ REST API endpoint /api/queues/{vhost} with the appropriate pagination parameters.\nparams = { \u0026#39;page\u0026#39;: offset, \u0026#39;page_size\u0026#39;: batch_size, \u0026#39;columns\u0026#39;: \u0026#39;name,messages\u0026#39; } We retrieve queues in batches until we have processed all the available queues.\nProcessing Queues # As we retrieve the queues, we process them to determine which ones need to be deleted. In this example, we use a regular expression to check if the queue name does not contain the string \u0026ldquo;karna\u0026rdquo;.\nif not re.search(r\u0026#39;arjun\u0026#39;, queue_name): file.write(queue_name + \u0026#39;\\n\u0026#39;) We store the names of the queues to be deleted in a separate file named queues_to_delete.txt.\nDeleting Queues # After storing the queues to be deleted, we read the queues_to_delete.txt file and send DELETE requests to the RabbitMQ REST API endpoint /api/queues/{vhost}/{queue_name} to delete each queue.\ndelete_url = f\u0026#34;{api_url}/{queue_name}\u0026#34; response = requests.delete(delete_url, auth=(username, password)) We handle any errors that may occur during the deletion process and log the appropriate messages.\nEnhancements # To further improve the solution, we made a few enhancements:\nWe added exception handling to gracefully handle any errors that may occur during the JSON parsing or API requests. Instead of using a simple string comparison to identify queues for deletion, we switched to using a regular expression to search for specific queues. This provides a more precise way to match specific queue names. grep -E \u0026#39;[0-9]{32}_arjun\u0026#39; queues_to_delete.txt Conclusion # By leveraging the RabbitMQ REST API and writing a custom Python program, we were able to efficiently manage a large number of queues. The solution allows us to retrieve queues in batches, process them based on specific criteria, store the queues to be deleted, and delete them accordingly.\nThis approach overcomes the limitations of the management console and rabbitmqadmin tool when dealing with a high volume of queues. It provides a scalable and automated way to maintain a clean and organized RabbitMQ setup.\nRemember to adapt the code to your specific requirements and test it thoroughly in a non-production environment before running it on your production RabbitMQ instance.\nHappy queue management!\n","date":"18 June 2024","externalUrl":null,"permalink":"/posts/managing-rabbitmq-queues/","section":"Posts","summary":"Struggling to manage a large number of RabbitMQ queues? In this blog post, we\u0026rsquo;ll show you how to tackle this challenge head-on using Python and regular expressions. Discover how to set up \u003ccode\u003erabbitmqadmin\u003c/code\u003e, retrieve queues in batches, filter them using regex, and safely delete unnecessary ones. We\u0026rsquo;ll explore the RabbitMQ Management HTTP API and share best practices for exception handling and result storage. By automating queue management, you\u0026rsquo;ll save time and effort in maintaining your messaging infrastructure. Join us as we dive into the world of efficient RabbitMQ queue management and take control of your messaging system!","title":"Efficiently Managing RabbitMQ Queues with Python and Regular Expressions","type":"posts"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/tags/ignore_result/","section":"Tags","summary":"","title":"Ignore_result","type":"tags"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/","section":"Mrinank Verma","summary":"","title":"Mrinank Verma","type":"page"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/tags/quueues/","section":"Tags","summary":"","title":"Quueues","type":"tags"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/tags/rabbitmq/","section":"Tags","summary":"","title":"Rabbitmq","type":"tags"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/tags/requests/","section":"Tags","summary":"","title":"Requests","type":"tags"},{"content":"","date":"18 June 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" A sub-title # Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nibh nisl, vulputate eu lacus vitae, maximus molestie libero. Vestibulum laoreet, odio et sollicitudin sollicitudin, quam ligula tempus urna, sed sagittis eros eros ac felis. In tristique tortor vitae lacinia commodo. Mauris venenatis ultrices purus nec fermentum. Nunc sit amet aliquet metus. Morbi nisl felis, gravida ac consequat vitae, blandit eu libero. Curabitur porta est in dui elementum porttitor. Maecenas fermentum, tortor ac feugiat fringilla, orci sem sagittis massa, a congue risus ipsum vel massa. Aliquam sit amet nunc vulputate, facilisis neque in, faucibus nisl.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nibh nisl, vulputate eu lacus vitae, maximus molestie libero. Vestibulum laoreet, odio et sollicitudin sollicitudin, quam ligula tempus urna, sed sagittis eros eros ac felis. In tristique tortor vitae lacinia commodo. Mauris venenatis ultrices purus nec fermentum. Nunc sit amet aliquet metus. Morbi nisl felis, gravida ac consequat vitae, blandit eu libero. Curabitur porta est in dui elementum porttitor. Maecenas fermentum, tortor ac feugiat fringilla, orci sem sagittis massa, a congue risus ipsum vel massa. Aliquam sit amet nunc vulputate, facilisis neque in, faucibus nisl.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nibh nisl, vulputate eu lacus vitae, maximus molestie libero. Vestibulum laoreet, odio et sollicitudin sollicitudin, quam ligula tempus urna, sed sagittis eros eros ac felis. In tristique tortor vitae lacinia commodo. Mauris venenatis ultrices purus nec fermentum. Nunc sit amet aliquet metus. Morbi nisl felis, gravida ac consequat vitae, blandit eu libero. Curabitur porta est in dui elementum porttitor. Maecenas fermentum, tortor ac feugiat fringilla, orci sem sagittis massa, a congue risus ipsum vel massa. Aliquam sit amet nunc vulputate, facilisis neque in, faucibus nisl.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nibh nisl, vulputate eu lacus vitae, maximus molestie libero. Vestibulum laoreet, odio et sollicitudin sollicitudin, quam ligula tempus urna, sed sagittis eros eros ac felis. In tristique tortor vitae lacinia commodo. Mauris venenatis ultrices purus nec fermentum. Nunc sit amet aliquet metus. Morbi nisl felis, gravida ac consequat vitae, blandit eu libero. Curabitur porta est in dui elementum porttitor. Maecenas fermentum, tortor ac feugiat fringilla, orci sem sagittis massa, a congue risus ipsum vel massa. Aliquam sit amet nunc vulputate, facilisis neque in, faucibus nisl.\n","date":"14 August 2023","externalUrl":null,"permalink":"/posts/firstpost/","section":"Posts","summary":"This is my first post on my site","title":"My first post","type":"posts"},{"content":"","date":"14 August 2023","externalUrl":null,"permalink":"/tags/space/","section":"Tags","summary":"","title":"Space","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]